---
layout: post
title: "Spring AOP (2) - Spring 지원 프록시"
author: "jhkim593"
tags: Spring

---
앞선 장에서는 부가 기능 처리를 위한 동적 프록시 생성 방식인 CGLIB와 JDK 동적 프록시에 대해서 알아봤습니다.
이번 장에서는 프록시 생성을 위해 스프링에서 제공하는 여러 기능에 대해 살펴 보겠습니다.

>관련 코드는 [github](https://github.com/jhkim593/blog_code/tree/master/spring_transactional)를 참고해주세요

<br>
### 프록시 팩토리
인터페이스가 존재하면 JDK 동적 프록시를 사용해 프록시를 생성해주고, 구체 클래스만 있다면 CGLIB를 사용하여 프록시를 생성해주는 팩토리입니다.
프록시 팩토리는 프록시 생성시에 `Advice`라는 것을 사용하는데 이 `Advice`에 프록시가 호출하는 부가 기능을 정의하며 프록시 팩토리 내부에서 CGLIB인 경우 MethodInterceptor가 , JDK 동적 프록시인 경우 InvocationHandler가 이 `Advice`를 호출하도록 하기 때문에 프록시 생성 기술에 의존하기 않고 프록시를 생성할 수 있습니다.

그림으로 나타내면 다음과 같습니다.
<img src="https://user-images.githubusercontent.com/53510936/233639541-77afd7ac-38ae-4be1-8d8b-92e908829019.png"  width="600" height="300"/>
프록시 팩토리에서 내부적으로 MethodInterceptor 또는 InvocationHandler를 생성해서`Advice`를 호출하고 `Advice`는 실제 객체를 호출하게됩니다.

또한 `PointCut`을 통해 어디에 프록시를 적용할 것이며 어디에 부가 기능을 적용할지 필터링 하기 위한 설정을 할 수 있습니다.
기본적으로 프록시 생성시에 `Advice`와 `Pointcut`을 같이 사용하게되는데 `Adivce`1개와 `PointCut`1개를 가진 것을 `Advisor`라고 하며 프록시 생성시 적용할 수있습니다.
<img src="https://user-images.githubusercontent.com/53510936/233691466-46c82755-ddd6-498f-a664-84083a2d8ac8.png"  width="500" height="300"/>
프록시의 메소드를 호출하게 되면 `Advisor`의 `Pointcut`을 통해 `Advice`적용 여부를 확인하고 조건에 부합하면 `Advice`를 적용 , 부합하지 않으면 `Advice`를 적용하지 않고 실제 객체를 호출하게 됩니다.



<br>
### 여러 Advisor를 함께 적용
하나의 target에 여러 Advisor를 적용하는 경우 프록시가 Advisor마다 하나씩 생긴다고 생각할 수 있습니다. 하지만 스프링은 하나의 target에 여러 프록시를 생성하지 않고 **하나의 프록시에 여러 Advisor**를 적용해 최적화합니다.

<br>
### 빈 후처리기
스프링은 프록시 적용 대상 객체가 있을 때 실제 객체를 빈으로 등록하는 것이 아니라 프록시 객체를 빈으로 등록하게 되는데 이 과정에서 **빈 후처리기**를 사용합니다.

`@Bean` 이나 컴포넌트 스캔으로 스프링 빈을 등록하면, 스프링은 대상 객체를 생성해 빈 저장소에 등록하고 이 후 등록된 스프링 빈을 조회해서 사용하게 되는데

여기서 만약 **빈 후처리기**를 사용한다면 스프링 빈으로 등록되기 전에 해당 객체를 조작하거나 아예 다른 객체로 바꿔치기 할 수 있습니다.

<img src="https://user-images.githubusercontent.com/53510936/233426353-23f72b5c-5660-4a0a-80ea-a8d6543e1926.png"  width="600" height="300"/>

빈 후처리기를 사용한 빈 등록 순서는 다음과 같습니다.
1. 스프링이 빈 대상이 되는 객체를 생성
2. 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
3. 빈 후처리기는 해당 객체를 조작하거나 다른 객체로 바꿔치기해 빈을 반환
4. 전달된 빈이 그대로 반환되면 해당 빈이 등록되고 바꿔치기하면 다른 객체가 빈 저장소에 등록

<br>
### 자동 프록시 생성기
스프링은 대상 객체 대신 프록시를 빈으로 등록하기 위해 **자동 프록시 생성기**라는 빈 후처리기를 이미 만들어서 제공하고 있습니다.

스프링이 제공하는 빈 후처리기 사용을 위해 다음 의존성을 추가해야합니다.
~~~groovy
implementation 'org.springframework.boot:spring-boot-starter-aop'
~~~
해당 라이브러리를 추가하면 AOP 관련 클래스를 자동으로 스프링 빈에 등록합니다. AopAutoConfiguration이 활성화됩니다.


스프링 부트 자동 설정으로 `AnnotationAwareAspectJAutoProxyCreator`라는 빈 후처리기가 스프링 빈에 자동으로 등록되며 **스프링 빈으로 등록된 객체를 모두 탐색해** `Advisor`를 찾아 프록시가 필요한 곳에 자동으로 프록시를 적용합니다. `Advisor`안에는 `Pointcut` 또한 포함되어있기 때문에 어떤 빈에 프록시를 적용할지 알 수있고 `Advice`로 부가기능을 적용합니다.


자동으로 프록시를 생성해주는 `AnnotationAwareAspectJAutoProxyCreator` 동작을 그림으로 나타내면 다음과 같습니다.
<img src="https://user-images.githubusercontent.com/53510936/233626811-98ce4a4d-07c9-4714-9132-6960d62deda6.png"  width="600" height="300"/>

기본적인 동작순서는 위와 동일하지만 `AnnotationAwareAspectJAutoProxyCreator`는 빈으로 등록된 `Advisor`를 모두 조회해서 `Advisor`에 포함된 `Pointcut`을 통해 프록시 적용 여부를 체크합니다. 클래스 정보와 더불어 해당 객체의 모든 메소드를 매칭해보며 한개의 메소드라도 `Pointcut`조건에 만족하면 `Proxyfactory`를 통해 해당 객체에 프록시를 생성 후 반환해 스프링 빈에 등록합니다.

<br>
### AspectJExpressionPointcut
자동 프록시 생성기에서 `PointCut`은 다음 2가지를 위해 사용됩니다.
- 포인트컷을 사용해서 프록시 적용대상을 선정
  - 클래스 , 메소드 조건을 모두 비교해서 `PointCut`조건에 맞는 메소드가 하나라도 있다면 프록시를 생성합니다.
- 생성된 프록시에 어떤 메소드가 호출되었을 때 `Advice`를 적용할지 판단
  - 생성된 프록시는 내부적으로 InvocationHandler나 MethodInterceptor를 구현해서 `Advice`를 호출하는데 `Advice`를 호출하는 메소드를 `Pointcut`을 보고 판단하게 됩니다.

위 2가지 목적을 위해 패키지에 메소드이름 까지 함께 지정하는 정밀한 `Pointcut`이 필요합니다.

스프링은 정밀한 `Pointcut`을 위해 **AspectJExpressionPointcut**라는 스프링 AOP에 특화된 표현식을 지원합니다.

해당 표현식에 대한 내용은 아래에서 자세하게 다루겠습니다.

<br>

### @Aspect
프록시를 적용하기 위해 `Pointcut`과 `Advice`가 포함된 `Advisor`를 스프링 빈으로 등록하면 자동 프록시 생성기가 해당 빈들을 조회해 프록시를 빈으로 대신 등록해준다는 것을 위에서 다뤘는데
@Aspect 는 프록시 적용을 위한 `Advisor`를 편리하게 생성할 수 있는 어노테이션입니다. 스프링은 @Aspect로 선언된 `Advisor`를 통해 프록시 적용 대상에 부합하면 프록시를 적용합니다.


`@Aspect`를 기반으로 프록시가 생성되는 과정은 다음과 같습니다.
<img src="https://user-images.githubusercontent.com/53510936/233771747-671dbc96-1a00-4d4b-a9fb-ba422fe80f49.png
"  width="600" height="300"/>
1. 스프링이 빈 대상이되는 객체를 생성한다.
2. 생성된 객체가 스프링 컨테이너에 등록되기전 빈 후처리기에 전달된다.
3. `@Aspect`로 정의된 `Advisor`를 모두 조회한다.
4. `Advisor`에 포함된 `Pointcut`을 사용해서 해당 객체가 프록시 적용 대상인지 판단한다. 해당 객체의 클래스 정보를 비롯해서 모든 메소드에 대해서 확인하고 하나라도 만족하게되면 프록시 적용대상이 된다.
5. 프록시 적용 대상이면 프록시를 반환하고 아니면 원본 객체를 반환한다.
6. 반환된 객체가 스피링 빈으로 등록된다.

예시를 위해 프록시를 적용하기 위한 서비스 클래스와 Aspect 설정 클래스를 생성하겠습니다.

AspectTestService
~~~java
@Slf4j
@Service
public class AspectTestService {
    public void call(){
        log.info("AspectTestService call 메소드 호출");
    }
}
~~~

<br>
Aspect1
~~~java
@Aspect
@Slf4j
@Component
public class Aspect1 {

    @Around("execution(* com.example.aop.aspect..*(..))")
    public Object timeCheck(ProceedingJoinPoint joinPoint){
        log.info("start");
        long startTime = System.currentTimeMillis();

        //타겟 객체 메소드 호출
        Object result = null;
        try {
            result = joinPoint.proceed();
        } catch (Throwable throwable) {
        }

        long endTime = System.currentTimeMillis();

        log.info("end");
        log.info("resultTime={}", endTime - startTime);
        return result;
    }
}
~~~
- `@Aspect` : 어노테이션 기반 프록시를 적용
- `@Around("execution(* com.example.aop.aspect..*(..))")` : AspectJ 표현식을 사용해서 대상을 설정
- timeCheck 메소드 : `Advice`로 프록시 적용 대상에 부가 기능을 추가
- joinPoint : 내부에서 실제 호출 대상 , 전달 인자 , 어떤 객체 어떤 메소드가 호출되었는지 데이터가 포함
- `joinPoint.proceed`: 실제 타겟을 호출

<br>
테스트 코드를 통해 프록시가 적용되었는지 확인해보겠습니다.
~~~java
@SpringBootTest
@Slf4j
class AspectTestServiceTest {

    @Autowired
    AspectTestService aspectTestService;

    @Test
    public void call(){
        log.info("isProxy : {}",AopUtils.isAopProxy(aspectTestService));
        aspectTestService.call("call");
    }
}
~~~java
`AopUtils.isAopProxy`를 사용하면 프록시 적용 여부를 확인할 수 있습니다.

<br>
테스트 결과
~~~console
2023-04-23 18:05:17.809  INFO 14540 --- [    Test worker] c.e.aop.aspect.AspectTestServiceTest     : isProxy : true
2023-04-23 18:05:17.819  INFO 14540 --- [    Test worker] com.example.aop.aspect.Aspect        : start
2023-04-23 18:05:17.837  INFO 14540 --- [    Test worker] c.example.aop.aspect.AspectTestService   : AspectTestService call 메소드 호출
2023-04-23 18:05:17.837  INFO 14540 --- [    Test worker] com.example.aop.aspect.Aspect        : end
2023-04-23 18:05:17.837  INFO 14540 --- [    Test worker] com.example.aop.aspect.Aspect        : resultTime=17
~~~
프록시가 적용돼 @Aspect에 정의한 `Advice`가 먼저 동작한 것을 확인할 수 있습니다.

다음장에서는 @Aspect를 사용한 `Advisor` 설정에 대해 좀 더 자세하게 알아보겠습니다.

## Reference

[Spring 핵심원리 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8/dashboard)
