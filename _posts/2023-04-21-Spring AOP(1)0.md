---
layout: post
title: "Spring AOP (2) - Spring 지원 프록시"
author: "jhkim593"
tags: Spring

---
앞선 장에서는 부가 기능 처리를 위한 동적 프록시 생성 방식인 CGLIB와 JDK 동적 프록시에 대해서 알아봤습니다.
이번 장에서는 CGLIB와 JDK 동적 프록시 방식을 각각 구현해서 사용하는 것이 아닌 통합해서 관리하기 위해 스프링에서 제공하는 기능에 대해 살펴 보겠습니다.

### 프록시 팩토리
인터페이스가 존재하면 JDK 동적 프록시를 사용해 프록시를 생성해주고, 구체 클래스만 있다면 CGLIB를 사용하여 프록시를 생성해주는 팩토리입니다.
프록시 팩토리 사용시 `Advice`에 프록시가 호출하는 부가 기능을 정의하며 `Advice`를 통해 프록시 팩토리 내부에서 CGLIB인 경우 MethodInterceptor가 , JDK 동적 프록시인 경우 InvocationHandler가 이 `Advice`를 호출하도록 하기 때문에 프록시 생성 기술에 의존하지 않아도 됩니다.

또한 `PointCut`을 통해 어디에 프록시를 적용할 것이며 부가 기능을 적용할지 필터링 하기 위한 설정을 할 수 있습니다.

`Adivce`1개와 `PointCut`1개를 가진 것을 `Advisor`라고합니다.

<img src="https://user-images.githubusercontent.com/53510936/233639541-77afd7ac-38ae-4be1-8d8b-92e908829019.png"  width="800" height="300"/>

### 여러 Advisor를 함께 적용
하나의 target에 여러 Advisor를 적용하는 경우 프록시가 Advisor마다 하나씩 생긴다고 생각할 수 있다. 하지만 스프링은 하나의 target에 여러 프록시를 생성하지 않고 하나의 프록시에 여러 Advisor를 적용해 최적화합니다.

### 빈 후처리기
스프링은 실제 객체를 빈으로 등록하는 것이 아니라 프록시 객체를 빈으로 등록하게 되는데 이 과정에서 **빈 후처리기**가 사용됩니다.

`@Bean` 이나 컴포넌트 스캔으로 스프링 빈을 등록하면, 스프링은 대상 객체를 생성하고 스프링 컨테이너
내부의 빈 저장소에 등록하고 이후에 컨테이너에 등록된 스프링 빈을 조회해서 사용하게 됩니다.
빈으로 등록하기 직전 해당 객체를 조작하기 위해 빈 후처리기를 사용합니다.

빈 후처리기는 객체를 조작할수도 있지만 아예 다른 객체로 바꿔치기 하는것도 가능합니다.

<img src="https://user-images.githubusercontent.com/53510936/233426353-23f72b5c-5660-4a0a-80ea-a8d6543e1926.png"  width="800" height="300"/>

빈 후처리기를 사용한 빈 등록 순서는 다음과 같습니다.
1. 스프링이 빈 대상이 되는 객체를 생성
2. 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
3. 빈 후처리기는 해당 객체를 조작하거나 다른 객체로 바꿔치기해 빈을 반환
4. 전달된 빈이 그대로 반환되면 해당 빈이 등록되고 바꿔치기하면 다른 객체가 빈 저장소에 등록

스프링은 해당 빈 후처리기를 따로 구현할 필요 없이 이미 만들어서 제공하고 있습니다.

스프링이 제공하는 빈 후처리기 사용을 위해 다음 의존성을 추가해야합니다.
~~~groovy
implementation 'org.springframework.boot:spring-boot-starter-aop'
~~~
해당 라이브러리를 추가하면 AOP 관련 클래스를 자동으로 스프링 빈에 등록합니다. AopAutoConfiguration이 활성화됩니다.


스프링 부트 자동 설정으로 `AnnotationAwareAspectJAutoProxyCreator`라는 빈 후처리기가 스프링 빈에 자동으로 등록됩니다. 등록된 빈 후처리기는 **스프링 빈으로 등록된 객체를 모두 탐색해** `Advisor`를 찾아 프록시가 필요한 곳에 자동으로 프록시를 적용합니다. `Advisor`안에는 `Pointcut` 또한 포함되어있기 때문에 어떤 빈에 프록시를 적용할지 알 수있고 `Advice`로 부가기능을 적용합니다.


자동으로 프록시를 생성해주는 `AnnotationAwareAspectJAutoProxyCreator` 동작을 그림으로 나타내면 다음과 같습니다.
<img src="https://user-images.githubusercontent.com/53510936/233626811-98ce4a4d-07c9-4714-9132-6960d62deda6.png"  width="800" height="300"/>

기본적인 동작순서는 위와 동일하지만 `AnnotationAwareAspectJAutoProxyCreator`는 빈으로 등록된 `Advisor`를 조회해서 `Advisor`에 포함된 `Pointcut`을 통해 프록시 적용 여부를 체크합니다. 클래스 정보와 더불어 해당 객체의 모든 메소드를 매칭해보며 한개의 메소드라도 `Pointcut`조건에 만족하면 `Proxyfactory`를 통해 해당 객체에 프록시를 생성 후 반환해 스프링 빈에 등록합니다.

**AspectJExpressionPointcut**
자동 프록시 생성기에서 `PointCut`은 다음 2가지를 위해 사용됩니다.
- 포인트컷을 사용해서 프록시 적용대상을 선정
  - 클래스 , 메소드 조건을 모두 비교해서 `PointCut`조건에 맞는 메소드가 하나라도 있다면 프록시를 생성합니다.
- 생성된 프록시에 어떤 메소드가 호출되었을 때 `Advice`를 적용할지 판단
  - 생성된 프록시는 내부적으로 InvocationHandler나 MethodInterceptor를 구현해서 `Advice`를 호출하는데 `Advice`를 호출하는 메소드를 `Pointcut`을 보고 판단하게 됩니다.

  다음 2가지 목적을 위해 패키지에 메소드이름 까지 함께 지정하기 위한 정밀한 `Pointcut`이 필요합니다.

스프링은 정밀한 `Pointcut`을 위해 **AspectJExpressionPointcut** 스프링 AOP에 특화된 표현식을 제공합니다.


### @Aspect





















##### 프록시 팩토리 기술 선택 방법
인터페이스가 있으면: JDK 동적 프록시, 인터페이스 기반 프록시
인터페이스가 없으면: CGLIB, 구체 클래스 기반 프록시
`proxyTargetClass=true` : CGLIB, 구체 클래스 기반 프록시, 인터페이스 여부와 상관없음




## Reference

[Spring 핵심원리 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8/dashboard)
