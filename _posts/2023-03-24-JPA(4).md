---
layout: post
title: "JPA 조회 성능 최적화 (3) - 컬렉션 조회 최적화 ( batch fetch size )"
author: "jhkim593"
tags: JPA
---
앞선장에서는 컬렉션 또한 fetch join을 통해 한번의 쿼리로 조회가 가능했지만 페이징이 불가능 하다는 한계점에 대해서 다뤄보았는데
이번장에서는 컬렉션 조회 최적화와 페이징 처리까지 모두 가능한 Hibernate에 batch fetch size 설정을 알아보도록 하겠습니다.

## batch fetch size
Hibernate에서는 여러 자식들이 있을때 N+1 문제를 회피하기 위해 **hibernate.default_batch_fetch_size** 라는 옵션을 사용할 수 있습니다.

batch fetch size 옵션은 하위 엔티티를 로딩할때 한번에 상위 엔티티 ID를 지정한 숫자만큼 **in Query**로 로딩해줍니다.
현재 프로젝트를 예로 batch-size:100으로 되어있으면, OrderItem을 조회 할 때 상위 엔티티인 Order의 id 100개를 in Query로 OrderItem을 조회하게 됩니다.
<br>

설정을 위해src/test/resources/application.yml에 다음과 같은 옵션을 추가합니다.
~~~yml
spring:
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        default_batch_fetch_size: 100 //  batch_fetch_size 설정
~~~

<br>
<img src="https://user-images.githubusercontent.com/53510936/230377175-0ef2323a-6565-4d58-923d-ab2e865b4d19.png"  width="800" height="250"/>


현재 삽입된 Order는 2개이며 첫번째 Order는 2개 orderItem , 두번째 Order는 3개 orderItem을 가지고 있습니다.
ToOne 관계는 페이징 처리시 문제가 생기지 않기 때문에 모두 fetch join 설정하고 batch fetch size로 각 Order의 OrderItem을 조회하겠습니다.
<br>

~~~java
em.createQuery("select distinct o from  Order o " +
               "join fetch o.member m " +
               "join fetch o.delivery d", Order.class)
                .getResultList();
~~~
해당 쿼리로 Order를 조회 후 지연로딩을 통해 각 OrderItem을 조회했습니다.

~~~console
Hibernate:
    select
        distinct order0_.order_id as order_id1_4_0_,
        member1_.member_id as member_i1_2_1_,
        delivery2_.delivery_id as delivery1_0_2_,
        order0_.delivery_id as delivery4_4_0_,
        order0_.member_id as member_i5_4_0_,
        order0_.order_date as order_da2_4_0_,
        order0_.status as status3_4_0_,
        member1_.city as city2_2_1_,
        member1_.street as street3_2_1_,
        member1_.zipcode as zipcode4_2_1_,
        member1_.name as name5_2_1_,
        delivery2_.city as city2_0_2_,
        delivery2_.street as street3_0_2_,
        delivery2_.zipcode as zipcode4_0_2_,
        delivery2_.status as status5_0_2_
    from
        orders order0_
    inner join
        member member1_
            on order0_.member_id=member1_.member_id
    inner join
        delivery delivery2_
            on order0_.delivery_id=delivery2_.delivery_id
Hibernate:
    select
        orderitems0_.order_id as order_id5_3_1_,
        orderitems0_.order_item_id as order_it1_3_1_,
        orderitems0_.order_item_id as order_it1_3_0_,
        orderitems0_.count as count2_3_0_,
        orderitems0_.item_id as item_id4_3_0_,
        orderitems0_.order_id as order_id5_3_0_,
        orderitems0_.order_price as order_pr3_3_0_
    from
        order_item orderitems0_
    where
        orderitems0_.order_id in (
            ?, ?
        )
Hibernate:
    select
        item0_.item_id as item_id1_1_0_,
        item0_.name as name2_1_0_,
        item0_.price as price3_1_0_,
        item0_.stock_quantity as stock_qu4_1_0_
    from
        item item0_
    where
        item0_.item_id in (
            ?, ?, ?, ?, ?
        )
~~~
로그를 확인해보면 총 세번의 조회 쿼리가 날라간 것을 확인 할 수있습니다.<br>

첫번째 쿼리에서 Order와 fetch join을 통해 Delivery , Member가 같이 조회됐습니다.
<br>

두번째 쿼리를 살펴보면 batch fetch size설정으로 인해 상위 객체인 Order의 각 id를 in Query로 OrderItem을 한번에 조회한 것을 확인 할 수 있습니다.
<br>

세번째 쿼리를 살펴보면 batch fetch size설정으로 인해 상위 객체인 Item의 각 id를 in Query로 한번에 조회한 것을 확인 할 수 있습니다.

이전장에서 다룬 컬렉션을 fetch join 조회했을 때 한번의 쿼리로 조회 할 수 있었지만 **페이징**이 불가능 했습니다.
batch fetch size를 사용하면 fetch join 보다는 더 많은 쿼리가 발생하지만 in Query로 연관 객체를 조회해 **db 데이터 전송량이 감소**하며 무엇보다 이 방식은 **페이징**이 가능합니다.


이어서 페이징 처리를 위한 쿼리를 날려 보겠습니다.
~~~java
em.createQuery("select distinct o from  Order o " +
               "join fetch o.member m " +
               "join fetch o.delivery d", Order.class)
                .setFirstResult(0)
                .setMaxResults(2)
                .getResultList();
~~~

~~~console
select
        distinct order0_.order_id as order_id1_4_0_,
        member1_.member_id as member_i1_2_1_,
        delivery2_.delivery_id as delivery1_0_2_,
        order0_.delivery_id as delivery4_4_0_,
        order0_.member_id as member_i5_4_0_,
        order0_.order_date as order_da2_4_0_,
        order0_.status as status3_4_0_,
        member1_.city as city2_2_1_,
        member1_.street as street3_2_1_,
        member1_.zipcode as zipcode4_2_1_,
        member1_.name as name5_2_1_,
        delivery2_.city as city2_0_2_,
        delivery2_.street as street3_0_2_,
        delivery2_.zipcode as zipcode4_0_2_,
        delivery2_.status as status5_0_2_
    from
        orders order0_
    inner join
        member member1_
            on order0_.member_id=member1_.member_id
    inner join
        delivery delivery2_
            on order0_.delivery_id=delivery2_.delivery_id limit ?
Hibernate:
    select
        orderitems0_.order_id as order_id5_3_1_,
        orderitems0_.order_item_id as order_it1_3_1_,
        orderitems0_.order_item_id as order_it1_3_0_,
        orderitems0_.count as count2_3_0_,
        orderitems0_.item_id as item_id4_3_0_,
        orderitems0_.order_id as order_id5_3_0_,
        orderitems0_.order_price as order_pr3_3_0_
    from
        order_item orderitems0_
    where
        orderitems0_.order_id in (
            ?, ?
        )
Hibernate:
    select
        item0_.item_id as item_id1_1_0_,
        item0_.name as name2_1_0_,
        item0_.price as price3_1_0_,
        item0_.stock_quantity as stock_qu4_1_0_
    from
        item item0_
    where
        item0_.item_id in (
            ?, ?, ?, ?, ?
        )

~~~
ToOne 관계만 fetch join했기때문에 첫번째 쿼리에서 limit query를 통해 Order를 조회를 조회한 것을 확인 할수 있고
이후에 batch fetch size 수만큼 로딩을 통해 연관 객체를 조회하는 것을 확인 할 수 있었습니다.

batch fetch size의 크기는 100~1000정도를 권장하며 순간 부하를 어느정도 받쳐줄 수 있는지에 따라 설정하면 될것입니다.

추가로 batch fetch size는 개별 설정으로도 가능한데 `@BatchSize` 어노테이션을 필드, 메소드, 클래스단에 사이즈와 같이 설정하시면 됩니다.

<br>
## 결론
- ToOne 관계
  - fetch join을 통해 조회 -> 페이징 영향 없음
- ToMany 관계
  - 페이징 필요 없음
    - fetch join을 통해 조회 (2개 이상 컬렉션 조회시 MultipleBagFetchException 발생함)
  - 페이징 필요
    - hibernate.default_batch_fetch_size 설정을 통해 조회 쿼리를 최적화
